const require_filter = require('./filter.cjs');
const require_logger = require('./logger.cjs');
const require_sink = require('./sink.cjs');

//#region src/config.ts
/**
* The current configuration, if any.  Otherwise, `null`.
*/
let currentConfig = null;
/**
* Strong references to the loggers.
* This is to prevent the loggers from being garbage collected so that their
* sinks and filters are not removed.
*/
const strongRefs = /* @__PURE__ */ new Set();
/**
* Disposables to dispose when resetting the configuration.
*/
const disposables = /* @__PURE__ */ new Set();
/**
* Async disposables to dispose when resetting the configuration.
*/
const asyncDisposables = /* @__PURE__ */ new Set();
/**
* Check if a config is for the meta logger.
*/
function isLoggerConfigMeta(cfg) {
	return cfg.category.length === 0 || cfg.category.length === 1 && cfg.category[0] === "logtape" || cfg.category.length === 2 && cfg.category[0] === "logtape" && cfg.category[1] === "meta";
}
/**
* Configure the loggers with the specified configuration.
*
* Note that if the given sinks or filters are disposable, they will be
* disposed when the configuration is reset, or when the process exits.
*
* @example
* ```typescript
* await configure({
*   sinks: {
*     console: getConsoleSink(),
*   },
*   filters: {
*     slow: (log) =>
*       "duration" in log.properties &&
*       log.properties.duration as number > 1000,
*   },
*   loggers: [
*     {
*       category: "my-app",
*       sinks: ["console"],
*       lowestLevel: "info",
*     },
*     {
*       category: ["my-app", "sql"],
*       filters: ["slow"],
*       lowestLevel: "debug",
*     },
*     {
*       category: "logtape",
*       sinks: ["console"],
*       lowestLevel: "error",
*     },
*   ],
* });
* ```
*
* @param config The configuration.
*/
async function configure(config) {
	if (currentConfig != null && !config.reset) throw new ConfigError("Already configured; if you want to reset, turn on the reset flag.");
	await reset();
	try {
		configureInternal(config, true);
	} catch (e) {
		if (e instanceof ConfigError) await reset();
		throw e;
	}
}
/**
* Configure sync loggers with the specified configuration.
*
* Note that if the given sinks or filters are disposable, they will be
* disposed when the configuration is reset, or when the process exits.
*
* Also note that passing async sinks or filters will throw. If
* necessary use {@link resetSync} or {@link disposeSync}.
*
* @example
* ```typescript
* configureSync({
*   sinks: {
*     console: getConsoleSink(),
*   },
*   loggers: [
*     {
*       category: "my-app",
*       sinks: ["console"],
*       lowestLevel: "info",
*     },
*     {
*       category: "logtape",
*       sinks: ["console"],
*       lowestLevel: "error",
*     },
*   ],
* });
* ```
*
* @param config The configuration.
* @since 0.9.0
*/
function configureSync(config) {
	if (currentConfig != null && !config.reset) throw new ConfigError("Already configured; if you want to reset, turn on the reset flag.");
	if (asyncDisposables.size > 0) throw new ConfigError("Previously configured async disposables are still active. Use configure() instead or explicitly dispose them using dispose().");
	resetSync();
	try {
		configureInternal(config, false);
	} catch (e) {
		if (e instanceof ConfigError) resetSync();
		throw e;
	}
}
function configureInternal(config, allowAsync) {
	currentConfig = config;
	let metaConfigured = false;
	const configuredCategories = /* @__PURE__ */ new Set();
	for (const cfg of config.loggers) {
		if (isLoggerConfigMeta(cfg)) metaConfigured = true;
		const categoryKey = Array.isArray(cfg.category) ? JSON.stringify(cfg.category) : JSON.stringify([cfg.category]);
		if (configuredCategories.has(categoryKey)) throw new ConfigError(`Duplicate logger configuration for category: ${categoryKey}. Each category can only be configured once.`);
		configuredCategories.add(categoryKey);
		const logger = require_logger.LoggerImpl.getLogger(cfg.category);
		for (const sinkId of cfg.sinks ?? []) {
			const sink = config.sinks[sinkId];
			if (!sink) throw new ConfigError(`Sink not found: ${sinkId}.`);
			logger.sinks.push(sink);
		}
		logger.parentSinks = cfg.parentSinks ?? "inherit";
		if (cfg.lowestLevel !== void 0) logger.lowestLevel = cfg.lowestLevel;
		for (const filterId of cfg.filters ?? []) {
			const filter = config.filters?.[filterId];
			if (filter === void 0) throw new ConfigError(`Filter not found: ${filterId}.`);
			logger.filters.push(require_filter.toFilter(filter));
		}
		strongRefs.add(logger);
	}
	require_logger.LoggerImpl.getLogger().contextLocalStorage = config.contextLocalStorage;
	for (const sink of Object.values(config.sinks)) {
		if (Symbol.asyncDispose in sink) if (allowAsync) asyncDisposables.add(sink);
		else throw new ConfigError("Async disposables cannot be used with configureSync().");
		if (Symbol.dispose in sink) disposables.add(sink);
	}
	for (const filter of Object.values(config.filters ?? {})) {
		if (filter == null || typeof filter === "string") continue;
		if (Symbol.asyncDispose in filter) if (allowAsync) asyncDisposables.add(filter);
		else throw new ConfigError("Async disposables cannot be used with configureSync().");
		if (Symbol.dispose in filter) disposables.add(filter);
	}
	if ("process" in globalThis && !("Deno" in globalThis)) {
		const proc = globalThis.process;
		if (proc?.on) proc.on("exit", allowAsync ? dispose : disposeSync);
	} else addEventListener("unload", allowAsync ? dispose : disposeSync);
	const meta = require_logger.LoggerImpl.getLogger(["logtape", "meta"]);
	if (!metaConfigured) meta.sinks.push(require_sink.getConsoleSink());
	meta.info("LogTape loggers are configured.  Note that LogTape itself uses the meta logger, which has category {metaLoggerCategory}.  The meta logger purposes to log internal errors such as sink exceptions.  If you are seeing this message, the meta logger is automatically configured.  It's recommended to configure the meta logger with a separate sink so that you can easily notice if logging itself fails or is misconfigured.  To turn off this message, configure the meta logger with higher log levels than {dismissLevel}.  See also <https://logtape.org/manual/categories#meta-logger>.", {
		metaLoggerCategory: ["logtape", "meta"],
		dismissLevel: "info"
	});
}
/**
* Get the current configuration, if any.  Otherwise, `null`.
* @returns The current configuration, if any.  Otherwise, `null`.
*/
function getConfig() {
	return currentConfig;
}
/**
* Reset the configuration.  Mostly for testing purposes.
*/
async function reset() {
	await dispose();
	resetInternal();
}
/**
* Reset the configuration.  Mostly for testing purposes. Will not clear async
* sinks, only use with sync sinks. Use {@link reset} if you have async sinks.
* @since 0.9.0
*/
function resetSync() {
	disposeSync();
	resetInternal();
}
function resetInternal() {
	const rootLogger = require_logger.LoggerImpl.getLogger([]);
	rootLogger.resetDescendants();
	delete rootLogger.contextLocalStorage;
	strongRefs.clear();
	currentConfig = null;
}
/**
* Dispose of the disposables.
*/
async function dispose() {
	disposeSync();
	const promises = [];
	for (const disposable of asyncDisposables) {
		promises.push(disposable[Symbol.asyncDispose]());
		asyncDisposables.delete(disposable);
	}
	await Promise.all(promises);
}
/**
* Dispose of the sync disposables. Async disposables will be untouched,
* use {@link dispose} if you have async sinks.
* @since 0.9.0
*/
function disposeSync() {
	for (const disposable of disposables) disposable[Symbol.dispose]();
	disposables.clear();
}
/**
* A configuration error.
*/
var ConfigError = class extends Error {
	/**
	* Constructs a new configuration error.
	* @param message The error message.
	*/
	constructor(message) {
		super(message);
		this.name = "ConfigureError";
	}
};

//#endregion
exports.ConfigError = ConfigError;
exports.configure = configure;
exports.configureSync = configureSync;
exports.dispose = dispose;
exports.disposeSync = disposeSync;
exports.getConfig = getConfig;
exports.reset = reset;
exports.resetSync = resetSync;