{"version":3,"file":"wordwrap.js","names":["text: string","maxWidth: number","indentWidth: number","wrappedLines: string[]","indent: string","lines: string[]"],"sources":["../src/wordwrap.ts"],"sourcesContent":["/**\n * @fileoverview\n * Word wrapping utilities for terminal output\n *\n * This module provides functions for wrapping text at specified widths\n * while preserving proper indentation and handling Unicode characters\n * correctly.\n */\n\nimport { getDisplayWidth } from \"./wcwidth.ts\";\n\n/**\n * Wrap text at specified width with proper indentation for continuation lines.\n * Automatically detects the message start position from the first line.\n *\n * @param text The text to wrap (may contain ANSI escape codes)\n * @param maxWidth Maximum width in terminal columns\n * @param indentWidth Indentation width for continuation lines\n * @returns Wrapped text with proper indentation\n */\nexport function wrapText(\n  text: string,\n  maxWidth: number,\n  indentWidth: number,\n): string {\n  if (maxWidth <= 0) return text;\n\n  const displayWidth = getDisplayWidth(text);\n  // If text has newlines (multiline interpolated values), always process it\n  // even if it fits within the width\n  if (displayWidth <= maxWidth && !text.includes(\"\\n\")) return text;\n\n  const indent = \" \".repeat(Math.max(0, indentWidth));\n\n  // Check if text contains newlines (from interpolated values like Error objects)\n  if (text.includes(\"\\n\")) {\n    // Split by existing newlines and process each line\n    const lines = text.split(\"\\n\");\n    const wrappedLines: string[] = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const lineDisplayWidth = getDisplayWidth(line);\n\n      if (lineDisplayWidth <= maxWidth) {\n        // Line doesn't need wrapping, but add indentation if it's not the first line\n        if (i === 0) {\n          wrappedLines.push(line);\n        } else {\n          wrappedLines.push(indent + line);\n        }\n      } else {\n        // Line needs wrapping\n        const wrappedLine = wrapSingleLine(line, maxWidth, indent);\n        if (i === 0) {\n          wrappedLines.push(wrappedLine);\n        } else {\n          // For continuation lines from interpolated values, add proper indentation\n          const subLines = wrappedLine.split(\"\\n\");\n          for (let j = 0; j < subLines.length; j++) {\n            if (j === 0) {\n              wrappedLines.push(indent + subLines[j]);\n            } else {\n              wrappedLines.push(subLines[j]);\n            }\n          }\n        }\n      }\n    }\n\n    return wrappedLines.join(\"\\n\");\n  }\n\n  // Process as a single line since log records should not have newlines in the formatted output\n  return wrapSingleLine(text, maxWidth, indent);\n}\n\n/**\n * Wrap a single line of text (without existing newlines) at word boundaries.\n * Preserves ANSI escape codes and handles Unicode character widths correctly.\n *\n * @param text The text to wrap (single line, may contain ANSI codes)\n * @param maxWidth Maximum width in terminal columns\n * @param indent Indentation string for continuation lines\n * @returns Wrapped text with newlines and proper indentation\n */\nexport function wrapSingleLine(\n  text: string,\n  maxWidth: number,\n  indent: string,\n): string {\n  // Split text into chunks while preserving ANSI codes\n  const lines: string[] = [];\n  let currentLine = \"\";\n  let currentDisplayWidth = 0;\n  let i = 0;\n\n  while (i < text.length) {\n    // Check for ANSI escape sequence\n    if (text[i] === \"\\x1b\" && text[i + 1] === \"[\") {\n      // Find the end of the ANSI sequence\n      let j = i + 2;\n      while (j < text.length && text[j] !== \"m\") {\n        j++;\n      }\n      if (j < text.length) {\n        j++; // Include the 'm'\n        currentLine += text.slice(i, j);\n        i = j;\n        continue;\n      }\n    }\n\n    const char = text[i];\n\n    // Check if adding this character would exceed the width\n    if (currentDisplayWidth >= maxWidth && char !== \" \") {\n      // Try to find a good break point (space) before the current position\n      const breakPoint = currentLine.lastIndexOf(\" \");\n      if (breakPoint > 0) {\n        // Break at the space\n        lines.push(currentLine.slice(0, breakPoint));\n        currentLine = indent + currentLine.slice(breakPoint + 1) + char;\n        currentDisplayWidth = getDisplayWidth(currentLine);\n      } else {\n        // No space found, hard break\n        lines.push(currentLine);\n        currentLine = indent + char;\n        currentDisplayWidth = getDisplayWidth(currentLine);\n      }\n    } else {\n      currentLine += char;\n      // Recalculate display width properly for Unicode characters\n      currentDisplayWidth = getDisplayWidth(currentLine);\n    }\n\n    i++;\n  }\n\n  if (currentLine.trim()) {\n    lines.push(currentLine);\n  }\n\n  // Filter out empty lines (lines with only indentation/spaces)\n  const filteredLines = lines.filter((line) => line.trim().length > 0);\n\n  return filteredLines.join(\"\\n\");\n}\n"],"mappings":";;;;;;;;;;;;AAoBA,SAAgB,SACdA,MACAC,UACAC,aACQ;AACR,KAAI,YAAY,EAAG,QAAO;CAE1B,MAAM,eAAe,gBAAgB,KAAK;AAG1C,KAAI,gBAAgB,aAAa,KAAK,SAAS,KAAK,CAAE,QAAO;CAE7D,MAAM,SAAS,IAAI,OAAO,KAAK,IAAI,GAAG,YAAY,CAAC;AAGnD,KAAI,KAAK,SAAS,KAAK,EAAE;EAEvB,MAAM,QAAQ,KAAK,MAAM,KAAK;EAC9B,MAAMC,eAAyB,CAAE;AAEjC,OAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;GACrC,MAAM,OAAO,MAAM;GACnB,MAAM,mBAAmB,gBAAgB,KAAK;AAE9C,OAAI,oBAAoB,SAEtB,KAAI,MAAM,EACR,cAAa,KAAK,KAAK;OAEvB,cAAa,KAAK,SAAS,KAAK;QAE7B;IAEL,MAAM,cAAc,eAAe,MAAM,UAAU,OAAO;AAC1D,QAAI,MAAM,EACR,cAAa,KAAK,YAAY;SACzB;KAEL,MAAM,WAAW,YAAY,MAAM,KAAK;AACxC,UAAK,IAAI,IAAI,GAAG,IAAI,SAAS,QAAQ,IACnC,KAAI,MAAM,EACR,cAAa,KAAK,SAAS,SAAS,GAAG;SAEvC,cAAa,KAAK,SAAS,GAAG;IAGnC;GACF;EACF;AAED,SAAO,aAAa,KAAK,KAAK;CAC/B;AAGD,QAAO,eAAe,MAAM,UAAU,OAAO;AAC9C;;;;;;;;;;AAWD,SAAgB,eACdH,MACAC,UACAG,QACQ;CAER,MAAMC,QAAkB,CAAE;CAC1B,IAAI,cAAc;CAClB,IAAI,sBAAsB;CAC1B,IAAI,IAAI;AAER,QAAO,IAAI,KAAK,QAAQ;AAEtB,MAAI,KAAK,OAAO,UAAU,KAAK,IAAI,OAAO,KAAK;GAE7C,IAAI,IAAI,IAAI;AACZ,UAAO,IAAI,KAAK,UAAU,KAAK,OAAO,IACpC;AAEF,OAAI,IAAI,KAAK,QAAQ;AACnB;AACA,mBAAe,KAAK,MAAM,GAAG,EAAE;AAC/B,QAAI;AACJ;GACD;EACF;EAED,MAAM,OAAO,KAAK;AAGlB,MAAI,uBAAuB,YAAY,SAAS,KAAK;GAEnD,MAAM,aAAa,YAAY,YAAY,IAAI;AAC/C,OAAI,aAAa,GAAG;AAElB,UAAM,KAAK,YAAY,MAAM,GAAG,WAAW,CAAC;AAC5C,kBAAc,SAAS,YAAY,MAAM,aAAa,EAAE,GAAG;AAC3D,0BAAsB,gBAAgB,YAAY;GACnD,OAAM;AAEL,UAAM,KAAK,YAAY;AACvB,kBAAc,SAAS;AACvB,0BAAsB,gBAAgB,YAAY;GACnD;EACF,OAAM;AACL,kBAAe;AAEf,yBAAsB,gBAAgB,YAAY;EACnD;AAED;CACD;AAED,KAAI,YAAY,MAAM,CACpB,OAAM,KAAK,YAAY;CAIzB,MAAM,gBAAgB,MAAM,OAAO,CAAC,SAAS,KAAK,MAAM,CAAC,SAAS,EAAE;AAEpE,QAAO,cAAc,KAAK,KAAK;AAChC"}