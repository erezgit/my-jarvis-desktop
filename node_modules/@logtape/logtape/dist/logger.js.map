{"version":3,"file":"logger.js","names":["category: string | readonly string[]","rootLogger: LoggerImpl | null","parent: LoggerImpl | null","category: readonly string[]","subcategory:\n      | string\n      | readonly [string]\n      | readonly [string, ...(readonly string[])]","child: LoggerImpl | undefined","properties: Record<string, unknown>","record: LogRecord","level: LogLevel","record: Omit<LogRecord, \"category\"> | LogRecord","bypassSinks?: Set<Sink>","fullRecord: LogRecord","rawMessage: string","properties: Record<string, unknown> | (() => Record<string, unknown>)","cachedProps: Record<string, unknown> | undefined","callback: LogCallback","rawMessage: TemplateStringsArray | undefined","msg: unknown[] | undefined","messageTemplate: TemplateStringsArray","values: unknown[]","message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>","logger: LoggerImpl","subcategory: string | readonly [string] | readonly [string, ...string[]]","message: string","record: Omit<LogRecord, \"category\">","template: string","message: unknown[]","prop: unknown","template: TemplateStringsArray","values: readonly unknown[]"],"sources":["../src/logger.ts"],"sourcesContent":["import type { ContextLocalStorage } from \"./context.ts\";\nimport type { Filter } from \"./filter.ts\";\nimport { compareLogLevel, type LogLevel } from \"./level.ts\";\nimport type { LogRecord } from \"./record.ts\";\nimport type { Sink } from \"./sink.ts\";\n\n/**\n * A logger interface.  It provides methods to log messages at different\n * severity levels.\n *\n * ```typescript\n * const logger = getLogger(\"category\");\n * logger.trace `A trace message with ${value}`\n * logger.debug `A debug message with ${value}.`;\n * logger.info `An info message with ${value}.`;\n * logger.warn `A warning message with ${value}.`;\n * logger.error `An error message with ${value}.`;\n * logger.fatal `A fatal error message with ${value}.`;\n * ```\n */\nexport interface Logger {\n  /**\n   * The category of the logger.  It is an array of strings.\n   */\n  readonly category: readonly string[];\n\n  /**\n   * The logger with the supercategory of the current logger.  If the current\n   * logger is the root logger, this is `null`.\n   */\n  readonly parent: Logger | null;\n\n  /**\n   * Get a child logger with the given subcategory.\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const subLogger = logger.getChild(\"sub-category\");\n   * ```\n   *\n   * The above code is equivalent to:\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const subLogger = getLogger([\"category\", \"sub-category\"]);\n   * ```\n   *\n   * @param subcategory The subcategory.\n   * @returns The child logger.\n   */\n  getChild(\n    subcategory: string | readonly [string] | readonly [string, ...string[]],\n  ): Logger;\n\n  /**\n   * Get a logger with contextual properties.  This is useful for\n   * log multiple messages with the shared set of properties.\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const ctx = logger.with({ foo: 123, bar: \"abc\" });\n   * ctx.info(\"A message with {foo} and {bar}.\");\n   * ctx.warn(\"Another message with {foo}, {bar}, and {baz}.\", { baz: true });\n   * ```\n   *\n   * The above code is equivalent to:\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * logger.info(\"A message with {foo} and {bar}.\", { foo: 123, bar: \"abc\" });\n   * logger.warn(\n   *   \"Another message with {foo}, {bar}, and {baz}.\",\n   *   { foo: 123, bar: \"abc\", baz: true },\n   * );\n   * ```\n   *\n   * @param properties\n   * @returns\n   * @since 0.5.0\n   */\n  with(properties: Record<string, unknown>): Logger;\n\n  /**\n   * Log a trace message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.trace `A trace message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   * @since 0.12.0\n   */\n  trace(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a trace message with properties.\n   *\n   * ```typescript\n   * logger.trace('A trace message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.trace(\n   *   'A trace message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   * @since 0.12.0\n   */\n  trace(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a trace values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.trace({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.trace('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.trace('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.12.0\n   */\n  trace(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a trace message.  Use this when the message values are expensive\n   * to compute and should only be computed if the message is actually logged.\n   *\n   * ```typescript\n   * logger.trace(l => l`A trace message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   * @since 0.12.0\n   */\n  trace(callback: LogCallback): void;\n\n  /**\n   * Log a debug message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.debug `A debug message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  debug(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a debug message with properties.\n   *\n   * ```typescript\n   * logger.debug('A debug message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.debug(\n   *   'A debug message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  debug(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a debug values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.debug({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.debug('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.debug('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  debug(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a debug message.  Use this when the message values are expensive\n   * to compute and should only be computed if the message is actually logged.\n   *\n   * ```typescript\n   * logger.debug(l => l`A debug message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  debug(callback: LogCallback): void;\n\n  /**\n   * Log an informational message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.info `An info message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  info(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log an informational message with properties.\n   *\n   * ```typescript\n   * logger.info('An info message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.info(\n   *   'An info message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  info(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log an informational values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.info({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.info('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.info('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  info(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log an informational message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.info(l => l`An info message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  info(callback: LogCallback): void;\n\n  /**\n   * Log a warning message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.warn `A warning message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  warn(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a warning message with properties.\n   *\n   * ```typescript\n   * logger.warn('A warning message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.warn(\n   *   'A warning message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  warn(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a warning values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.warn({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.warn('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.warn('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  warn(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a warning message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.warn(l => l`A warning message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  warn(callback: LogCallback): void;\n\n  /**\n   * Log a warning message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.warning `A warning message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   * @since 0.12.0\n   */\n  warning(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a warning message with properties.\n   *\n   * ```typescript\n   * logger.warning('A warning message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.warning(\n   *   'A warning message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   * @since 0.12.0\n   */\n  warning(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a warning values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.warning({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.warning('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.warning('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.12.0\n   */\n  warning(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a warning message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.warning(l => l`A warning message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   * @since 0.12.0\n   */\n  warning(callback: LogCallback): void;\n\n  /**\n   * Log an error message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.error `An error message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  error(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log an error message with properties.\n   *\n   * ```typescript\n   * logger.warn('An error message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.error(\n   *   'An error message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  error(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log an error values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.error({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.error('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.error('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  error(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log an error message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.error(l => l`An error message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  error(callback: LogCallback): void;\n\n  /**\n   * Log a fatal error message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.fatal `A fatal error message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  fatal(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a fatal error message with properties.\n   *\n   * ```typescript\n   * logger.warn('A fatal error message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.fatal(\n   *   'A fatal error message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  fatal(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a fatal error values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.fatal({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.fatal('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.fatal('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  fatal(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a fatal error message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.fatal(l => l`A fatal error message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  fatal(callback: LogCallback): void;\n\n  /**\n   * Emits a log record with custom fields while using this logger's\n   * category.\n   *\n   * This is a low-level API for integration scenarios where you need full\n   * control over the log record, particularly for preserving timestamps\n   * from external systems.\n   *\n   * ```typescript\n   * const logger = getLogger([\"my-app\", \"integration\"]);\n   *\n   * // Emit a log with a custom timestamp\n   * logger.emit({\n   *   timestamp: kafkaLog.originalTimestamp,\n   *   level: \"info\",\n   *   message: [kafkaLog.message],\n   *   rawMessage: kafkaLog.message,\n   *   properties: {\n   *     source: \"kafka\",\n   *     partition: kafkaLog.partition,\n   *     offset: kafkaLog.offset,\n   *   },\n   * });\n   * ```\n   *\n   * @param record Log record without category field (category comes from\n   *               the logger instance)\n   * @since 1.1.0\n   */\n  emit(record: Omit<LogRecord, \"category\">): void;\n}\n\n/**\n * A logging callback function.  It is used to defer the computation of a\n * message template until it is actually logged.\n * @param prefix The message template prefix.\n * @returns The rendered message array.\n */\nexport type LogCallback = (prefix: LogTemplatePrefix) => unknown[];\n\n/**\n * A logging template prefix function.  It is used to log a message in\n * a {@link LogCallback} function.\n * @param message The message template strings array.\n * @param values The message template values.\n * @returns The rendered message array.\n */\nexport type LogTemplatePrefix = (\n  message: TemplateStringsArray,\n  ...values: unknown[]\n) => unknown[];\n\n/**\n * A function type for logging methods in the {@link Logger} interface.\n * @since 1.0.0\n */\nexport interface LogMethod {\n  /**\n   * Log a message with the given level using a template string.\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  (\n    message: TemplateStringsArray,\n    ...values: readonly unknown[]\n  ): void;\n\n  /**\n   * Log a message with the given level with properties.\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  (\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a message with the given level with no message.\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   */\n  (properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a message with the given level.\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  (callback: LogCallback): void;\n}\n\n/**\n * Get a logger with the given category.\n *\n * ```typescript\n * const logger = getLogger([\"my-app\"]);\n * ```\n *\n * @param category The category of the logger.  It can be a string or an array\n *                 of strings.  If it is a string, it is equivalent to an array\n *                 with a single element.\n * @returns The logger.\n */\nexport function getLogger(category: string | readonly string[] = []): Logger {\n  return LoggerImpl.getLogger(category);\n}\n\n/**\n * The symbol for the global root logger.\n */\nconst globalRootLoggerSymbol = Symbol.for(\"logtape.rootLogger\");\n\n/**\n * The global root logger registry.\n */\ninterface GlobalRootLoggerRegistry {\n  [globalRootLoggerSymbol]?: LoggerImpl;\n}\n\n/**\n * A logger implementation.  Do not use this directly; use {@link getLogger}\n * instead.  This class is exported for testing purposes.\n */\nexport class LoggerImpl implements Logger {\n  readonly parent: LoggerImpl | null;\n  readonly children: Record<string, LoggerImpl | WeakRef<LoggerImpl>>;\n  readonly category: readonly string[];\n  readonly sinks: Sink[];\n  parentSinks: \"inherit\" | \"override\" = \"inherit\";\n  readonly filters: Filter[];\n  lowestLevel: LogLevel | null = \"trace\";\n  contextLocalStorage?: ContextLocalStorage<Record<string, unknown>>;\n\n  static getLogger(category: string | readonly string[] = []): LoggerImpl {\n    let rootLogger: LoggerImpl | null = globalRootLoggerSymbol in globalThis\n      ? ((globalThis as GlobalRootLoggerRegistry)[globalRootLoggerSymbol] ??\n        null)\n      : null;\n    if (rootLogger == null) {\n      rootLogger = new LoggerImpl(null, []);\n      (globalThis as GlobalRootLoggerRegistry)[globalRootLoggerSymbol] =\n        rootLogger;\n    }\n    if (typeof category === \"string\") return rootLogger.getChild(category);\n    if (category.length === 0) return rootLogger;\n    return rootLogger.getChild(category as readonly [string, ...string[]]);\n  }\n\n  private constructor(parent: LoggerImpl | null, category: readonly string[]) {\n    this.parent = parent;\n    this.children = {};\n    this.category = category;\n    this.sinks = [];\n    this.filters = [];\n  }\n\n  getChild(\n    subcategory:\n      | string\n      | readonly [string]\n      | readonly [string, ...(readonly string[])],\n  ): LoggerImpl {\n    const name = typeof subcategory === \"string\" ? subcategory : subcategory[0];\n    const childRef = this.children[name];\n    let child: LoggerImpl | undefined = childRef instanceof LoggerImpl\n      ? childRef\n      : childRef?.deref();\n    if (child == null) {\n      child = new LoggerImpl(this, [...this.category, name]);\n      this.children[name] = \"WeakRef\" in globalThis\n        ? new WeakRef(child)\n        : child;\n    }\n    if (typeof subcategory === \"string\" || subcategory.length === 1) {\n      return child;\n    }\n    return child.getChild(\n      subcategory.slice(1) as [string, ...(readonly string[])],\n    );\n  }\n\n  /**\n   * Reset the logger.  This removes all sinks and filters from the logger.\n   */\n  reset(): void {\n    while (this.sinks.length > 0) this.sinks.shift();\n    this.parentSinks = \"inherit\";\n    while (this.filters.length > 0) this.filters.shift();\n    this.lowestLevel = \"trace\";\n  }\n\n  /**\n   * Reset the logger and all its descendants.  This removes all sinks and\n   * filters from the logger and all its descendants.\n   */\n  resetDescendants(): void {\n    for (const child of Object.values(this.children)) {\n      const logger = child instanceof LoggerImpl ? child : child.deref();\n      if (logger != null) logger.resetDescendants();\n    }\n    this.reset();\n  }\n\n  with(properties: Record<string, unknown>): Logger {\n    return new LoggerCtx(this, { ...properties });\n  }\n\n  filter(record: LogRecord): boolean {\n    for (const filter of this.filters) {\n      if (!filter(record)) return false;\n    }\n    if (this.filters.length < 1) return this.parent?.filter(record) ?? true;\n    return true;\n  }\n\n  *getSinks(level: LogLevel): Iterable<Sink> {\n    if (\n      this.lowestLevel === null || compareLogLevel(level, this.lowestLevel) < 0\n    ) {\n      return;\n    }\n    if (this.parent != null && this.parentSinks === \"inherit\") {\n      for (const sink of this.parent.getSinks(level)) yield sink;\n    }\n    for (const sink of this.sinks) yield sink;\n  }\n\n  emit(record: Omit<LogRecord, \"category\">): void;\n  emit(record: LogRecord, bypassSinks?: Set<Sink>): void;\n  emit(\n    record: Omit<LogRecord, \"category\"> | LogRecord,\n    bypassSinks?: Set<Sink>,\n  ): void {\n    const fullRecord: LogRecord = \"category\" in record\n      ? record as LogRecord\n      : { ...record, category: this.category };\n\n    if (\n      this.lowestLevel === null ||\n      compareLogLevel(fullRecord.level, this.lowestLevel) < 0 ||\n      !this.filter(fullRecord)\n    ) {\n      return;\n    }\n    for (const sink of this.getSinks(fullRecord.level)) {\n      if (bypassSinks?.has(sink)) continue;\n      try {\n        sink(fullRecord);\n      } catch (error) {\n        const bypassSinks2 = new Set(bypassSinks);\n        bypassSinks2.add(sink);\n        metaLogger.log(\n          \"fatal\",\n          \"Failed to emit a log record to sink {sink}: {error}\",\n          { sink, error, record: fullRecord },\n          bypassSinks2,\n        );\n      }\n    }\n  }\n\n  log(\n    level: LogLevel,\n    rawMessage: string,\n    properties: Record<string, unknown> | (() => Record<string, unknown>),\n    bypassSinks?: Set<Sink>,\n  ): void {\n    const implicitContext =\n      LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};\n    let cachedProps: Record<string, unknown> | undefined = undefined;\n    const record: LogRecord = typeof properties === \"function\"\n      ? {\n        category: this.category,\n        level,\n        timestamp: Date.now(),\n        get message() {\n          return parseMessageTemplate(rawMessage, this.properties);\n        },\n        rawMessage,\n        get properties() {\n          if (cachedProps == null) {\n            cachedProps = {\n              ...implicitContext,\n              ...properties(),\n            };\n          }\n          return cachedProps;\n        },\n      }\n      : {\n        category: this.category,\n        level,\n        timestamp: Date.now(),\n        message: parseMessageTemplate(rawMessage, {\n          ...implicitContext,\n          ...properties,\n        }),\n        rawMessage,\n        properties: { ...implicitContext, ...properties },\n      };\n    this.emit(record, bypassSinks);\n  }\n\n  logLazily(\n    level: LogLevel,\n    callback: LogCallback,\n    properties: Record<string, unknown> = {},\n  ): void {\n    const implicitContext =\n      LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};\n    let rawMessage: TemplateStringsArray | undefined = undefined;\n    let msg: unknown[] | undefined = undefined;\n    function realizeMessage(): [unknown[], TemplateStringsArray] {\n      if (msg == null || rawMessage == null) {\n        msg = callback((tpl, ...values) => {\n          rawMessage = tpl;\n          return renderMessage(tpl, values);\n        });\n        if (rawMessage == null) throw new TypeError(\"No log record was made.\");\n      }\n      return [msg, rawMessage];\n    }\n    this.emit({\n      category: this.category,\n      level,\n      get message() {\n        return realizeMessage()[0];\n      },\n      get rawMessage() {\n        return realizeMessage()[1];\n      },\n      timestamp: Date.now(),\n      properties: { ...implicitContext, ...properties },\n    });\n  }\n\n  logTemplate(\n    level: LogLevel,\n    messageTemplate: TemplateStringsArray,\n    values: unknown[],\n    properties: Record<string, unknown> = {},\n  ): void {\n    const implicitContext =\n      LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};\n    this.emit({\n      category: this.category,\n      level,\n      message: renderMessage(messageTemplate, values),\n      rawMessage: messageTemplate,\n      timestamp: Date.now(),\n      properties: { ...implicitContext, ...properties },\n    });\n  }\n\n  trace(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"trace\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"trace\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"trace\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"trace\", message as TemplateStringsArray, values);\n    }\n  }\n\n  debug(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"debug\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"debug\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"debug\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"debug\", message as TemplateStringsArray, values);\n    }\n  }\n\n  info(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"info\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"info\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"info\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"info\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warn(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\n        \"warning\",\n        message,\n        (values[0] ?? {}) as Record<string, unknown>,\n      );\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"warning\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"warning\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"warning\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warning(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    this.warn(message, ...values);\n  }\n\n  error(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"error\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"error\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"error\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"error\", message as TemplateStringsArray, values);\n    }\n  }\n\n  fatal(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"fatal\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"fatal\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"fatal\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"fatal\", message as TemplateStringsArray, values);\n    }\n  }\n}\n\n/**\n * A logger implementation with contextual properties.  Do not use this\n * directly; use {@link Logger.with} instead.  This class is exported\n * for testing purposes.\n */\nexport class LoggerCtx implements Logger {\n  logger: LoggerImpl;\n  properties: Record<string, unknown>;\n\n  constructor(logger: LoggerImpl, properties: Record<string, unknown>) {\n    this.logger = logger;\n    this.properties = properties;\n  }\n\n  get category(): readonly string[] {\n    return this.logger.category;\n  }\n\n  get parent(): Logger | null {\n    return this.logger.parent;\n  }\n\n  getChild(\n    subcategory: string | readonly [string] | readonly [string, ...string[]],\n  ): Logger {\n    return this.logger.getChild(subcategory).with(this.properties);\n  }\n\n  with(properties: Record<string, unknown>): Logger {\n    return new LoggerCtx(this.logger, { ...this.properties, ...properties });\n  }\n\n  log(\n    level: LogLevel,\n    message: string,\n    properties: Record<string, unknown> | (() => Record<string, unknown>),\n    bypassSinks?: Set<Sink>,\n  ): void {\n    this.logger.log(\n      level,\n      message,\n      typeof properties === \"function\"\n        ? () => ({\n          ...this.properties,\n          ...properties(),\n        })\n        : { ...this.properties, ...properties },\n      bypassSinks,\n    );\n  }\n\n  logLazily(level: LogLevel, callback: LogCallback): void {\n    this.logger.logLazily(level, callback, this.properties);\n  }\n\n  logTemplate(\n    level: LogLevel,\n    messageTemplate: TemplateStringsArray,\n    values: unknown[],\n  ): void {\n    this.logger.logTemplate(level, messageTemplate, values, this.properties);\n  }\n\n  emit(record: Omit<LogRecord, \"category\">): void {\n    const recordWithContext = {\n      ...record,\n      properties: { ...this.properties, ...record.properties },\n    };\n    this.logger.emit(recordWithContext);\n  }\n\n  trace(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"trace\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"trace\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"trace\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"trace\", message as TemplateStringsArray, values);\n    }\n  }\n\n  debug(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"debug\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"debug\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"debug\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"debug\", message as TemplateStringsArray, values);\n    }\n  }\n\n  info(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"info\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"info\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"info\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"info\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warn(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\n        \"warning\",\n        message,\n        (values[0] ?? {}) as Record<string, unknown>,\n      );\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"warning\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"warning\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"warning\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warning(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    this.warn(message, ...values);\n  }\n\n  error(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"error\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"error\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"error\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"error\", message as TemplateStringsArray, values);\n    }\n  }\n\n  fatal(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"fatal\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"fatal\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"fatal\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"fatal\", message as TemplateStringsArray, values);\n    }\n  }\n}\n\n/**\n * The meta logger.  It is a logger with the category `[\"logtape\", \"meta\"]`.\n */\nconst metaLogger = LoggerImpl.getLogger([\"logtape\", \"meta\"]);\n\n/**\n * Parse a message template into a message template array and a values array.\n * @param template The message template.\n * @param properties The values to replace placeholders with.\n * @returns The message template array and the values array.\n */\nexport function parseMessageTemplate(\n  template: string,\n  properties: Record<string, unknown>,\n): readonly unknown[] {\n  const length = template.length;\n  if (length === 0) return [\"\"];\n\n  // Fast path: no placeholders\n  if (!template.includes(\"{\")) return [template];\n\n  const message: unknown[] = [];\n  let startIndex = 0;\n\n  for (let i = 0; i < length; i++) {\n    const char = template[i];\n\n    if (char === \"{\") {\n      const nextChar = i + 1 < length ? template[i + 1] : \"\";\n\n      if (nextChar === \"{\") {\n        // Escaped { character - skip and continue\n        i++; // Skip the next {\n        continue;\n      }\n\n      // Find the closing }\n      const closeIndex = template.indexOf(\"}\", i + 1);\n      if (closeIndex === -1) {\n        // No closing } found, treat as literal text\n        continue;\n      }\n\n      // Add text before placeholder\n      const beforeText = template.slice(startIndex, i);\n      message.push(beforeText.replace(/{{/g, \"{\").replace(/}}/g, \"}\"));\n\n      // Extract and process placeholder key\n      const key = template.slice(i + 1, closeIndex);\n\n      // Resolve property value\n      let prop: unknown;\n\n      // Check for wildcard patterns\n      const trimmedKey = key.trim();\n      if (trimmedKey === \"*\") {\n        // This is a wildcard pattern\n        prop = key in properties\n          ? properties[key]\n          : \"*\" in properties\n          ? properties[\"*\"]\n          : properties;\n      } else {\n        // Regular property lookup with possible whitespace handling\n        if (key !== trimmedKey) {\n          // Key has leading/trailing whitespace\n          prop = key in properties ? properties[key] : properties[trimmedKey];\n        } else {\n          // Key has no leading/trailing whitespace\n          prop = properties[key];\n        }\n      }\n\n      message.push(prop);\n      i = closeIndex; // Move to the }\n      startIndex = i + 1;\n    } else if (char === \"}\" && i + 1 < length && template[i + 1] === \"}\") {\n      // Escaped } character - skip\n      i++; // Skip the next }\n    }\n  }\n\n  // Add remaining text\n  const remainingText = template.slice(startIndex);\n  message.push(remainingText.replace(/{{/g, \"{\").replace(/}}/g, \"}\"));\n\n  return message;\n}\n\n/**\n * Render a message template with values.\n * @param template The message template.\n * @param values The message template values.\n * @returns The message template values interleaved between the substitution\n *          values.\n */\nexport function renderMessage(\n  template: TemplateStringsArray,\n  values: readonly unknown[],\n): unknown[] {\n  const args = [];\n  for (let i = 0; i < template.length; i++) {\n    args.push(template[i]);\n    if (i < values.length) args.push(values[i]);\n  }\n  return args;\n}\n"],"mappings":"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"}