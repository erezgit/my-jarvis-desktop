import * as util from "#util";

//#region src/formatter.ts
/**
* The severity level abbreviations.
*/
const levelAbbreviations = {
	"trace": "TRC",
	"debug": "DBG",
	"info": "INF",
	"warning": "WRN",
	"error": "ERR",
	"fatal": "FTL"
};
/**
* A platform-specific inspect function.  In Deno, this is {@link Deno.inspect},
* and in Node.js/Bun it is `util.inspect()`.  If neither is available, it
* falls back to {@link JSON.stringify}.
*
* @param value The value to inspect.
* @param options The options for inspecting the value.
*                If `colors` is `true`, the output will be ANSI-colored.
* @returns The string representation of the value.
*/
const inspect = typeof document !== "undefined" || typeof navigator !== "undefined" && navigator.product === "ReactNative" ? (v) => JSON.stringify(v) : "Deno" in globalThis && "inspect" in globalThis.Deno && typeof globalThis.Deno.inspect === "function" ? (v, opts) => globalThis.Deno.inspect(v, {
	strAbbreviateSize: Infinity,
	iterableLimit: Infinity,
	...opts
}) : util != null && "inspect" in util && typeof util.inspect === "function" ? (v, opts) => util.inspect(v, {
	maxArrayLength: Infinity,
	maxStringLength: Infinity,
	...opts
}) : (v) => JSON.stringify(v);
function padZero(num) {
	return num < 10 ? `0${num}` : `${num}`;
}
function padThree(num) {
	return num < 10 ? `00${num}` : num < 100 ? `0${num}` : `${num}`;
}
const timestampFormatters = {
	"date-time-timezone": (ts) => {
		const d = new Date(ts);
		const year = d.getUTCFullYear();
		const month = padZero(d.getUTCMonth() + 1);
		const day = padZero(d.getUTCDate());
		const hour = padZero(d.getUTCHours());
		const minute = padZero(d.getUTCMinutes());
		const second = padZero(d.getUTCSeconds());
		const ms = padThree(d.getUTCMilliseconds());
		return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms} +00:00`;
	},
	"date-time-tz": (ts) => {
		const d = new Date(ts);
		const year = d.getUTCFullYear();
		const month = padZero(d.getUTCMonth() + 1);
		const day = padZero(d.getUTCDate());
		const hour = padZero(d.getUTCHours());
		const minute = padZero(d.getUTCMinutes());
		const second = padZero(d.getUTCSeconds());
		const ms = padThree(d.getUTCMilliseconds());
		return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms} +00`;
	},
	"date-time": (ts) => {
		const d = new Date(ts);
		const year = d.getUTCFullYear();
		const month = padZero(d.getUTCMonth() + 1);
		const day = padZero(d.getUTCDate());
		const hour = padZero(d.getUTCHours());
		const minute = padZero(d.getUTCMinutes());
		const second = padZero(d.getUTCSeconds());
		const ms = padThree(d.getUTCMilliseconds());
		return `${year}-${month}-${day} ${hour}:${minute}:${second}.${ms}`;
	},
	"time-timezone": (ts) => {
		const d = new Date(ts);
		const hour = padZero(d.getUTCHours());
		const minute = padZero(d.getUTCMinutes());
		const second = padZero(d.getUTCSeconds());
		const ms = padThree(d.getUTCMilliseconds());
		return `${hour}:${minute}:${second}.${ms} +00:00`;
	},
	"time-tz": (ts) => {
		const d = new Date(ts);
		const hour = padZero(d.getUTCHours());
		const minute = padZero(d.getUTCMinutes());
		const second = padZero(d.getUTCSeconds());
		const ms = padThree(d.getUTCMilliseconds());
		return `${hour}:${minute}:${second}.${ms} +00`;
	},
	"time": (ts) => {
		const d = new Date(ts);
		const hour = padZero(d.getUTCHours());
		const minute = padZero(d.getUTCMinutes());
		const second = padZero(d.getUTCSeconds());
		const ms = padThree(d.getUTCMilliseconds());
		return `${hour}:${minute}:${second}.${ms}`;
	},
	"date": (ts) => {
		const d = new Date(ts);
		const year = d.getUTCFullYear();
		const month = padZero(d.getUTCMonth() + 1);
		const day = padZero(d.getUTCDate());
		return `${year}-${month}-${day}`;
	},
	"rfc3339": (ts) => new Date(ts).toISOString(),
	"none": () => null
};
const levelRenderersCache = {
	ABBR: levelAbbreviations,
	abbr: {
		trace: "trc",
		debug: "dbg",
		info: "inf",
		warning: "wrn",
		error: "err",
		fatal: "ftl"
	},
	FULL: {
		trace: "TRACE",
		debug: "DEBUG",
		info: "INFO",
		warning: "WARNING",
		error: "ERROR",
		fatal: "FATAL"
	},
	full: {
		trace: "trace",
		debug: "debug",
		info: "info",
		warning: "warning",
		error: "error",
		fatal: "fatal"
	},
	L: {
		trace: "T",
		debug: "D",
		info: "I",
		warning: "W",
		error: "E",
		fatal: "F"
	},
	l: {
		trace: "t",
		debug: "d",
		info: "i",
		warning: "w",
		error: "e",
		fatal: "f"
	}
};
/**
* Get a text formatter with the specified options.  Although it's flexible
* enough to create a custom formatter, if you want more control, you can
* create a custom formatter that satisfies the {@link TextFormatter} type
* instead.
*
* For more information on the options, see {@link TextFormatterOptions}.
*
* By default, the formatter formats log records as follows:
*
* ```
* 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!
* ```
* @param options The options for the text formatter.
* @returns The text formatter.
* @since 0.6.0
*/
function getTextFormatter(options = {}) {
	const timestampRenderer = (() => {
		const tsOption = options.timestamp;
		if (tsOption == null) return timestampFormatters["date-time-timezone"];
		else if (tsOption === "disabled") return timestampFormatters["none"];
		else if (typeof tsOption === "string" && tsOption in timestampFormatters) return timestampFormatters[tsOption];
		else return tsOption;
	})();
	const categorySeparator = options.category ?? "·";
	const valueRenderer = options.value ?? inspect;
	const levelRenderer = (() => {
		const levelOption = options.level;
		if (levelOption == null || levelOption === "ABBR") return (level) => levelRenderersCache.ABBR[level];
		else if (levelOption === "abbr") return (level) => levelRenderersCache.abbr[level];
		else if (levelOption === "FULL") return (level) => levelRenderersCache.FULL[level];
		else if (levelOption === "full") return (level) => levelRenderersCache.full[level];
		else if (levelOption === "L") return (level) => levelRenderersCache.L[level];
		else if (levelOption === "l") return (level) => levelRenderersCache.l[level];
		else return levelOption;
	})();
	const formatter = options.format ?? (({ timestamp, level, category, message }) => `${timestamp ? `${timestamp} ` : ""}[${level}] ${category}: ${message}`);
	return (record) => {
		const msgParts = record.message;
		const msgLen = msgParts.length;
		let message;
		if (msgLen === 1) message = msgParts[0];
		else if (msgLen <= 6) {
			message = "";
			for (let i = 0; i < msgLen; i++) message += i % 2 === 0 ? msgParts[i] : valueRenderer(msgParts[i]);
		} else {
			const parts = new Array(msgLen);
			for (let i = 0; i < msgLen; i++) parts[i] = i % 2 === 0 ? msgParts[i] : valueRenderer(msgParts[i]);
			message = parts.join("");
		}
		const timestamp = timestampRenderer(record.timestamp);
		const level = levelRenderer(record.level);
		const category = typeof categorySeparator === "function" ? categorySeparator(record.category) : record.category.join(categorySeparator);
		const values = {
			timestamp,
			level,
			category,
			message,
			record
		};
		return `${formatter(values)}\n`;
	};
}
/**
* The default text formatter.  This formatter formats log records as follows:
*
* ```
* 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!
* ```
*
* @param record The log record to format.
* @returns The formatted log record.
*/
const defaultTextFormatter = getTextFormatter();
const RESET = "\x1B[0m";
const ansiColors = {
	black: "\x1B[30m",
	red: "\x1B[31m",
	green: "\x1B[32m",
	yellow: "\x1B[33m",
	blue: "\x1B[34m",
	magenta: "\x1B[35m",
	cyan: "\x1B[36m",
	white: "\x1B[37m"
};
const ansiStyles = {
	bold: "\x1B[1m",
	dim: "\x1B[2m",
	italic: "\x1B[3m",
	underline: "\x1B[4m",
	strikethrough: "\x1B[9m"
};
const defaultLevelColors = {
	trace: null,
	debug: "blue",
	info: "green",
	warning: "yellow",
	error: "red",
	fatal: "magenta"
};
/**
* Get an ANSI color formatter with the specified options.
*
* ![A preview of an ANSI color formatter.](https://i.imgur.com/I8LlBUf.png)
* @param option The options for the ANSI color formatter.
* @returns The ANSI color formatter.
* @since 0.6.0
*/
function getAnsiColorFormatter(options = {}) {
	const format = options.format;
	const timestampStyle = typeof options.timestampStyle === "undefined" ? "dim" : options.timestampStyle;
	const timestampColor = options.timestampColor ?? null;
	const timestampPrefix = `${timestampStyle == null ? "" : ansiStyles[timestampStyle]}${timestampColor == null ? "" : ansiColors[timestampColor]}`;
	const timestampSuffix = timestampStyle == null && timestampColor == null ? "" : RESET;
	const levelStyle = typeof options.levelStyle === "undefined" ? "bold" : options.levelStyle;
	const levelColors = options.levelColors ?? defaultLevelColors;
	const categoryStyle = typeof options.categoryStyle === "undefined" ? "dim" : options.categoryStyle;
	const categoryColor = options.categoryColor ?? null;
	const categoryPrefix = `${categoryStyle == null ? "" : ansiStyles[categoryStyle]}${categoryColor == null ? "" : ansiColors[categoryColor]}`;
	const categorySuffix = categoryStyle == null && categoryColor == null ? "" : RESET;
	return getTextFormatter({
		timestamp: "date-time-tz",
		value(value) {
			return inspect(value, { colors: true });
		},
		...options,
		format({ timestamp, level, category, message, record }) {
			const levelColor = levelColors[record.level];
			timestamp = `${timestampPrefix}${timestamp}${timestampSuffix}`;
			level = `${levelStyle == null ? "" : ansiStyles[levelStyle]}${levelColor == null ? "" : ansiColors[levelColor]}${level}${levelStyle == null && levelColor == null ? "" : RESET}`;
			return format == null ? `${timestamp} ${level} ${categoryPrefix}${category}:${categorySuffix} ${message}` : format({
				timestamp,
				level,
				category: `${categoryPrefix}${category}${categorySuffix}`,
				message,
				record
			});
		}
	});
}
/**
* A text formatter that uses ANSI colors to format log records.
*
* ![A preview of ansiColorFormatter.](https://i.imgur.com/I8LlBUf.png)
*
* @param record The log record to format.
* @returns The formatted log record.
* @since 0.5.0
*/
const ansiColorFormatter = getAnsiColorFormatter();
/**
* Get a [JSON Lines] formatter with the specified options.  The log records
* will be rendered as JSON objects, one per line, which is a common format
* for log files.  This format is also known as Newline-Delimited JSON (NDJSON).
* It looks like this:
*
* ```json
* {"@timestamp":"2023-11-14T22:13:20.000Z","level":"INFO","message":"Hello, world!","logger":"my.logger","properties":{"key":"value"}}
* ```
*
* [JSON Lines]: https://jsonlines.org/
* @param options The options for the JSON Lines formatter.
* @returns The JSON Lines formatter.
* @since 0.11.0
*/
function getJsonLinesFormatter(options = {}) {
	if (!options.categorySeparator && !options.message && !options.properties) return (record) => {
		if (record.message.length === 3) return JSON.stringify({
			"@timestamp": new Date(record.timestamp).toISOString(),
			level: record.level === "warning" ? "WARN" : record.level.toUpperCase(),
			message: record.message[0] + JSON.stringify(record.message[1]) + record.message[2],
			logger: record.category.join("."),
			properties: record.properties
		}) + "\n";
		if (record.message.length === 1) return JSON.stringify({
			"@timestamp": new Date(record.timestamp).toISOString(),
			level: record.level === "warning" ? "WARN" : record.level.toUpperCase(),
			message: record.message[0],
			logger: record.category.join("."),
			properties: record.properties
		}) + "\n";
		let msg = record.message[0];
		for (let i = 1; i < record.message.length; i++) msg += i & 1 ? JSON.stringify(record.message[i]) : record.message[i];
		return JSON.stringify({
			"@timestamp": new Date(record.timestamp).toISOString(),
			level: record.level === "warning" ? "WARN" : record.level.toUpperCase(),
			message: msg,
			logger: record.category.join("."),
			properties: record.properties
		}) + "\n";
	};
	const isTemplateMessage = options.message === "template";
	const propertiesOption = options.properties ?? "nest:properties";
	let joinCategory;
	if (typeof options.categorySeparator === "function") joinCategory = options.categorySeparator;
	else {
		const separator = options.categorySeparator ?? ".";
		joinCategory = (category) => category.join(separator);
	}
	let getProperties;
	if (propertiesOption === "flatten") getProperties = (properties) => properties;
	else if (propertiesOption.startsWith("prepend:")) {
		const prefix = propertiesOption.substring(8);
		if (prefix === "") throw new TypeError(`Invalid properties option: ${JSON.stringify(propertiesOption)}. It must be of the form "prepend:<prefix>" where <prefix> is a non-empty string.`);
		getProperties = (properties) => {
			const result = {};
			for (const key in properties) result[`${prefix}${key}`] = properties[key];
			return result;
		};
	} else if (propertiesOption.startsWith("nest:")) {
		const key = propertiesOption.substring(5);
		getProperties = (properties) => ({ [key]: properties });
	} else throw new TypeError(`Invalid properties option: ${JSON.stringify(propertiesOption)}. It must be "flatten", "prepend:<prefix>", or "nest:<key>".`);
	let getMessage;
	if (isTemplateMessage) getMessage = (record) => {
		if (typeof record.rawMessage === "string") return record.rawMessage;
		let msg = "";
		for (let i = 0; i < record.rawMessage.length; i++) msg += i % 2 < 1 ? record.rawMessage[i] : "{}";
		return msg;
	};
	else getMessage = (record) => {
		const msgLen = record.message.length;
		if (msgLen === 1) return record.message[0];
		let msg = "";
		for (let i = 0; i < msgLen; i++) msg += i % 2 < 1 ? record.message[i] : JSON.stringify(record.message[i]);
		return msg;
	};
	return (record) => {
		return JSON.stringify({
			"@timestamp": new Date(record.timestamp).toISOString(),
			level: record.level === "warning" ? "WARN" : record.level.toUpperCase(),
			message: getMessage(record),
			logger: joinCategory(record.category),
			...getProperties(record.properties)
		}) + "\n";
	};
}
/**
* The default [JSON Lines] formatter.  This formatter formats log records
* as JSON objects, one per line, which is a common format for log files.
* It looks like this:
*
* ```json
* {"@timestamp":"2023-11-14T22:13:20.000Z","level":"INFO","message":"Hello, world!","logger":"my.logger","properties":{"key":"value"}}
* ```
*
* You can customize the output by passing options to
* {@link getJsonLinesFormatter}.  For example, you can change the category
* separator, the message format, and how the properties are formatted.
*
* [JSON Lines]: https://jsonlines.org/
* @since 0.11.0
*/
const jsonLinesFormatter = getJsonLinesFormatter();
/**
* The styles for the log level in the console.
*/
const logLevelStyles = {
	"trace": "background-color: gray; color: white;",
	"debug": "background-color: gray; color: white;",
	"info": "background-color: white; color: black;",
	"warning": "background-color: orange; color: black;",
	"error": "background-color: red; color: white;",
	"fatal": "background-color: maroon; color: white;"
};
/**
* The default console formatter.
*
* @param record The log record to format.
* @returns The formatted log record, as an array of arguments for
*          {@link console.log}.
*/
function defaultConsoleFormatter(record) {
	let msg = "";
	const values = [];
	for (let i = 0; i < record.message.length; i++) if (i % 2 === 0) msg += record.message[i];
	else {
		msg += "%o";
		values.push(record.message[i]);
	}
	const date = new Date(record.timestamp);
	const time = `${date.getUTCHours().toString().padStart(2, "0")}:${date.getUTCMinutes().toString().padStart(2, "0")}:${date.getUTCSeconds().toString().padStart(2, "0")}.${date.getUTCMilliseconds().toString().padStart(3, "0")}`;
	return [
		`%c${time} %c${levelAbbreviations[record.level]}%c %c${record.category.join("·")} %c${msg}`,
		"color: gray;",
		logLevelStyles[record.level],
		"background-color: default;",
		"color: gray;",
		"color: default;",
		...values
	];
}

//#endregion
export { ansiColorFormatter, defaultConsoleFormatter, defaultTextFormatter, getAnsiColorFormatter, getJsonLinesFormatter, getTextFormatter, jsonLinesFormatter };
//# sourceMappingURL=formatter.js.map