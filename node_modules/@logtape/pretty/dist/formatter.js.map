{"version":3,"file":"formatter.js","names":["color: Color","style: Style","categoryColorMap: CategoryColorMap","patterns: CategoryPattern[]","category: readonly string[]","prefix: readonly string[]","defaultIcons: Record<LogLevel, string>","iconMap: Record<LogLevel, string>","options: PrettyFormatterOptions","baseIconMap: Record<LogLevel, string>","resolvedLevelColors: Record<LogLevel, Color>","levelMappings: Record<string, Record<LogLevel, string>>","level: LogLevel","timestampFormatters: Record<string, (ts: number) => string>","timestampFn: ((ts: number) => string | null) | null","wordWrapWidth: number","allLevels: LogLevel[]","record: LogRecord","indentWidth: number","maxWidth: number","useColors: boolean","inspectOptions: InspectOptions","prettyFormatter: TextFormatter"],"sources":["../src/formatter.ts"],"sourcesContent":["import {\n  getLogLevels,\n  type LogLevel,\n  type LogRecord,\n  type TextFormatter,\n  type TextFormatterOptions,\n} from \"@logtape/logtape\";\nimport { inspect, type InspectOptions } from \"#util\";\nimport { getOptimalWordWrapWidth } from \"./terminal.ts\";\nimport { truncateCategory, type TruncationStrategy } from \"./truncate.ts\";\nimport { getDisplayWidth, stripAnsi } from \"./wcwidth.ts\";\nimport { wrapText } from \"./wordwrap.ts\";\n\n/**\n * ANSI escape codes for styling\n */\nconst RESET = \"\\x1b[0m\";\nconst DIM = \"\\x1b[2m\";\n\n// Default true color values (referenced in JSDoc)\nconst defaultColors = {\n  trace: \"rgb(167,139,250)\", // Light purple\n  debug: \"rgb(96,165,250)\", // Light blue\n  info: \"rgb(52,211,153)\", // Emerald\n  warning: \"rgb(251,191,36)\", // Amber\n  error: \"rgb(248,113,113)\", // Light red\n  fatal: \"rgb(220,38,38)\", // Dark red\n  category: \"rgb(100,116,139)\", // Slate\n  message: \"rgb(148,163,184)\", // Light slate\n  timestamp: \"rgb(100,116,139)\", // Slate\n} as const;\n\n/**\n * ANSI style codes\n */\nconst styles = {\n  reset: RESET,\n  bold: \"\\x1b[1m\",\n  dim: DIM,\n  italic: \"\\x1b[3m\",\n  underline: \"\\x1b[4m\",\n  strikethrough: \"\\x1b[9m\",\n} as const;\n\n/**\n * Standard ANSI colors (16-color)\n */\nconst ansiColors = {\n  black: \"\\x1b[30m\",\n  red: \"\\x1b[31m\",\n  green: \"\\x1b[32m\",\n  yellow: \"\\x1b[33m\",\n  blue: \"\\x1b[34m\",\n  magenta: \"\\x1b[35m\",\n  cyan: \"\\x1b[36m\",\n  white: \"\\x1b[37m\",\n} as const;\n\n/**\n * Color type definition\n */\nexport type Color =\n  | keyof typeof ansiColors\n  | `rgb(${number},${number},${number})`\n  | `#${string}`\n  | null;\n\n/**\n * Category color mapping for prefix-based coloring.\n *\n * Maps category prefixes (as arrays) to colors. The formatter will match\n * categories against these prefixes and use the corresponding color.\n * Longer/more specific prefixes take precedence over shorter ones.\n *\n * @example\n * ```typescript\n * new Map([\n *   [[\"app\", \"auth\"], \"#ff6b6b\"],     // app.auth.* -> red\n *   [[\"app\", \"db\"], \"#4ecdc4\"],       // app.db.* -> teal\n *   [[\"app\"], \"#45b7d1\"],             // app.* (fallback) -> blue\n *   [[\"lib\"], \"#96ceb4\"],             // lib.* -> green\n * ])\n * ```\n */\nexport type CategoryColorMap = Map<readonly string[], Color>;\n\n/**\n * Internal representation of category prefix patterns\n */\ntype CategoryPattern = {\n  prefix: readonly string[];\n  color: Color;\n};\n\n/**\n * Style type definition - supports single styles, arrays of styles, or null\n */\nexport type Style = keyof typeof styles | (keyof typeof styles)[] | null;\n\n// Pre-compiled regex patterns for color parsing\nconst RGB_PATTERN = /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/;\nconst HEX_PATTERN = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/;\n\n/**\n * Helper function to convert color to ANSI escape code\n */\nfunction colorToAnsi(color: Color): string {\n  if (color === null) return \"\";\n  if (color in ansiColors) {\n    return ansiColors[color as keyof typeof ansiColors];\n  }\n\n  // Handle rgb() format\n  const rgbMatch = color.match(RGB_PATTERN);\n  if (rgbMatch) {\n    const [, r, g, b] = rgbMatch;\n    return `\\x1b[38;2;${r};${g};${b}m`;\n  }\n\n  // Handle hex format (#rrggbb or #rgb)\n  const hexMatch = color.match(HEX_PATTERN);\n  if (hexMatch) {\n    let hex = hexMatch[1];\n    // Convert 3-digit hex to 6-digit\n    if (hex.length === 3) {\n      hex = hex.split(\"\").map((c) => c + c).join(\"\");\n    }\n    const r = parseInt(hex.substr(0, 2), 16);\n    const g = parseInt(hex.substr(2, 2), 16);\n    const b = parseInt(hex.substr(4, 2), 16);\n    return `\\x1b[38;2;${r};${g};${b}m`;\n  }\n\n  return \"\";\n}\n\n/**\n * Helper function to convert style to ANSI escape code\n */\nfunction styleToAnsi(style: Style): string {\n  if (style === null) return \"\";\n  if (Array.isArray(style)) {\n    return style.map((s) => styles[s] || \"\").join(\"\");\n  }\n  return styles[style] || \"\";\n}\n\n/**\n * Converts a category color map to internal patterns and sorts them by specificity.\n * More specific (longer) prefixes come first for proper matching precedence.\n */\nfunction prepareCategoryPatterns(\n  categoryColorMap: CategoryColorMap,\n): CategoryPattern[] {\n  const patterns: CategoryPattern[] = [];\n\n  for (const [prefix, color] of categoryColorMap) {\n    patterns.push({ prefix, color });\n  }\n\n  // Sort by prefix length (descending) for most-specific-first matching\n  return patterns.sort((a, b) => b.prefix.length - a.prefix.length);\n}\n\n/**\n * Matches a category against category color patterns.\n * Returns the color of the first matching pattern, or null if no match.\n */\nfunction matchCategoryColor(\n  category: readonly string[],\n  patterns: CategoryPattern[],\n): Color {\n  for (const pattern of patterns) {\n    if (categoryMatches(category, pattern.prefix)) {\n      return pattern.color;\n    }\n  }\n  return null;\n}\n\n/**\n * Checks if a category matches a prefix pattern.\n * A category matches if it starts with all segments of the prefix.\n */\nfunction categoryMatches(\n  category: readonly string[],\n  prefix: readonly string[],\n): boolean {\n  if (prefix.length > category.length) {\n    return false;\n  }\n\n  for (let i = 0; i < prefix.length; i++) {\n    if (category[i] !== prefix[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Default icons for each log level\n */\nconst defaultIcons: Record<LogLevel, string> = {\n  trace: \"üîç\",\n  debug: \"üêõ\",\n  info: \"‚ú®\",\n  warning: \"‚ö°\",\n  error: \"‚ùå\",\n  fatal: \"üíÄ\",\n};\n\n/**\n * Normalize icon spacing to ensure consistent column alignment.\n *\n * All icons will be padded with spaces to match the width of the widest icon,\n * ensuring consistent prefix alignment across all log levels.\n *\n * @param iconMap The icon mapping to normalize\n * @returns A new icon map with consistent spacing\n */\nfunction normalizeIconSpacing(\n  iconMap: Record<LogLevel, string>,\n): Record<LogLevel, string> {\n  const entries = Object.entries(iconMap) as Array<[LogLevel, string]>;\n  const maxWidth = Math.max(\n    ...entries.map(([, icon]) => getDisplayWidth(icon)),\n  );\n\n  return Object.fromEntries(\n    entries.map(([level, icon]) => [\n      level,\n      icon + \" \".repeat(maxWidth - getDisplayWidth(icon)),\n    ]),\n  ) as Record<LogLevel, string>;\n}\n\n/**\n * Configuration options for the pretty formatter.\n *\n * This interface extends the base text formatter options while providing\n * extensive customization options for visual styling, layout control, and\n * development-focused features. It offers granular control over colors,\n * styles, and formatting similar to the ANSI color formatter.\n *\n * @since 1.0.0\n */\nexport interface PrettyFormatterOptions\n  extends Omit<TextFormatterOptions, \"category\" | \"value\" | \"format\"> {\n  /**\n   * Color for timestamp display when timestamps are enabled.\n   *\n   * Supports true color RGB values, hex colors, or ANSI color names.\n   * Set to `null` to disable timestamp coloring.\n   *\n   * @example\n   * ```typescript\n   * timestampColor: \"#888888\"        // Hex color\n   * timestampColor: \"rgb(128,128,128)\" // RGB color\n   * timestampColor: \"cyan\"           // ANSI color name\n   * timestampColor: null             // No color\n   * ```\n   *\n   * @default `\"rgb(100,116,139)\"` (slate gray)\n   */\n  readonly timestampColor?: Color;\n\n  /**\n   * Visual style applied to timestamp text.\n   *\n   * Controls text appearance like boldness, dimming, etc.\n   * Supports single styles, multiple styles combined, or no styling.\n   * Combines with `timestampColor` for full styling control.\n   *\n   * @example\n   * ```typescript\n   * timestampStyle: \"dim\"                    // Single style: dimmed text\n   * timestampStyle: \"bold\"                   // Single style: bold text\n   * timestampStyle: [\"bold\", \"underline\"]    // Multiple styles: bold + underlined\n   * timestampStyle: [\"dim\", \"italic\"]        // Multiple styles: dimmed + italic\n   * timestampStyle: null                     // No styling\n   * ```\n   *\n   * @default `\"dim\"`\n   */\n  readonly timestampStyle?: Style;\n\n  /**\n   * Custom colors for each log level.\n   *\n   * Allows fine-grained control over level appearance. Each level can have\n   * its own color scheme. Unspecified levels use built-in defaults.\n   * Set individual levels to `null` to disable coloring for that level.\n   *\n   * @example\n   * ```typescript\n   * levelColors: {\n   *   info: \"#00ff00\",     // Bright green for info\n   *   error: \"#ff0000\",    // Bright red for errors\n   *   warning: \"orange\",   // ANSI orange for warnings\n   *   debug: null,         // No color for debug\n   * }\n   * ```\n   *\n   * @default Built-in color scheme (purple trace, blue debug, green info, amber warning, red error, dark red fatal)\n   */\n  readonly levelColors?: Partial<Record<LogLevel, Color>>;\n\n  /**\n   * Visual style applied to log level text.\n   *\n   * Controls the appearance of the level indicator (e.g., \"info\", \"error\").\n   * Supports single styles, multiple styles combined, or no styling.\n   * Applied in addition to level-specific colors.\n   *\n   * @example\n   * ```typescript\n   * levelStyle: \"bold\"                    // Single style: bold level text\n   * levelStyle: \"underline\"               // Single style: underlined level text\n   * levelStyle: [\"bold\", \"underline\"]     // Multiple styles: bold + underlined\n   * levelStyle: [\"dim\", \"italic\"]         // Multiple styles: dimmed + italic\n   * levelStyle: null                      // No additional styling\n   * ```\n   *\n   * @default `\"underline\"`\n   */\n  readonly levelStyle?: Style;\n\n  /**\n   * Icon configuration for each log level.\n   *\n   * Controls the emoji/symbol displayed before each log entry.\n   * Provides visual quick-identification of log severity.\n   *\n   * - `true`: Use built-in emoji set (üîç trace, üêõ debug, ‚ú® info, ‚ö†Ô∏è warning, ‚ùå error, üíÄ fatal)\n   * - `false`: Disable all icons for clean text-only output\n   * - Object: Custom icon mapping, falls back to defaults for unspecified levels\n   *\n   * @example\n   * ```typescript\n   * icons: true                    // Use default emoji set\n   * icons: false                   // No icons\n   * icons: {\n   *   info: \"‚ÑπÔ∏è\",                  // Custom info icon\n   *   error: \"üî•\",                 // Custom error icon\n   *   warning: \"‚ö°\",               // Custom warning icon\n   * }\n   * ```\n   *\n   * @default `true` (use default emoji icons)\n   */\n  readonly icons?: boolean | Partial<Record<LogLevel, string>>;\n\n  /**\n   * Character(s) used to separate category hierarchy levels.\n   *\n   * Categories are hierarchical (e.g., [\"app\", \"auth\", \"jwt\"]) and this\n   * separator joins them for display (e.g., \"app.auth.jwt\").\n   *\n   * @example\n   * ```typescript\n   * categorySeparator: \"¬∑\"        // app¬∑auth¬∑jwt\n   * categorySeparator: \".\"        // app.auth.jwt\n   * categorySeparator: \":\"        // app:auth:jwt\n   * categorySeparator: \" > \"      // app > auth > jwt\n   * categorySeparator: \"::\"       // app::auth::jwt\n   * ```\n   *\n   * @default `\"¬∑\"` (interpunct)\n   */\n  readonly categorySeparator?: string;\n\n  /**\n   * Default color for category display.\n   *\n   * Used as fallback when no specific color is found in `categoryColorMap`.\n   * Controls the visual appearance of the category hierarchy display.\n   *\n   * @example\n   * ```typescript\n   * categoryColor: \"#666666\"        // Gray categories\n   * categoryColor: \"blue\"           // Blue categories\n   * categoryColor: \"rgb(100,150,200)\" // Light blue categories\n   * categoryColor: null             // No coloring\n   * ```\n   *\n   * @default `\"rgb(100,116,139)\"` (slate gray)\n   */\n  readonly categoryColor?: Color;\n\n  /**\n   * Category-specific color mapping based on prefixes.\n   *\n   * Maps category prefixes (as arrays) to colors for visual grouping.\n   * More specific (longer) prefixes take precedence over shorter ones.\n   * If no prefix matches, falls back to the default `categoryColor`.\n   *\n   * @example\n   * ```typescript\n   * new Map([\n   *   [[\"app\", \"auth\"], \"#ff6b6b\"],     // app.auth.* -> red\n   *   [[\"app\", \"db\"], \"#4ecdc4\"],       // app.db.* -> teal\n   *   [[\"app\"], \"#45b7d1\"],             // app.* (fallback) -> blue\n   *   [[\"lib\"], \"#96ceb4\"],             // lib.* -> green\n   * ])\n   * ```\n   */\n  readonly categoryColorMap?: CategoryColorMap;\n\n  /**\n   * Visual style applied to category text.\n   *\n   * Controls the appearance of the category hierarchy display.\n   * Supports single styles, multiple styles combined, or no styling.\n   * Applied in addition to category colors from `categoryColor` or `categoryColorMap`.\n   *\n   * @example\n   * ```typescript\n   * categoryStyle: \"dim\"                     // Single style: dimmed category text\n   * categoryStyle: \"italic\"                  // Single style: italic category text\n   * categoryStyle: [\"dim\", \"italic\"]         // Multiple styles: dimmed + italic\n   * categoryStyle: [\"bold\", \"underline\"]     // Multiple styles: bold + underlined\n   * categoryStyle: null                      // No additional styling\n   * ```\n   *\n   * @default `[\"dim\", \"italic\"]` (dimmed for subtle appearance)\n   */\n  readonly categoryStyle?: Style;\n\n  /**\n   * Maximum display width for category names.\n   *\n   * Controls layout consistency by limiting category width.\n   * Long categories are truncated according to `categoryTruncate` strategy.\n   *\n   * @default `20`\n   */\n  readonly categoryWidth?: number;\n\n  /**\n   * Strategy for truncating long category names.\n   *\n   * When categories exceed `categoryWidth`, this controls how truncation works.\n   * Smart truncation preserves important context while maintaining layout.\n   *\n   * - `\"middle\"`: Keep first and last parts (e.g., \"app.server‚Ä¶auth.jwt\")\n   * - `\"end\"`: Truncate at the end (e.g., \"app.server.middleware‚Ä¶\")\n   * - `false`: No truncation (ignores `categoryWidth`)\n   *\n   * @example\n   * ```typescript\n   * categoryTruncate: \"middle\"   // app.server‚Ä¶jwt (preserves context)\n   * categoryTruncate: \"end\"      // app.server.midd‚Ä¶ (linear truncation)\n   * categoryTruncate: false      // app.server.middleware.auth.jwt (full)\n   * ```\n   *\n   * @default `\"middle\"` (smart context-preserving truncation)\n   */\n  readonly categoryTruncate?: TruncationStrategy;\n\n  /**\n   * Color for log message text content.\n   *\n   * Controls the visual appearance of the actual log message content.\n   * Does not affect structured values, which use syntax highlighting.\n   *\n   * @example\n   * ```typescript\n   * messageColor: \"#ffffff\"        // White message text\n   * messageColor: \"green\"          // Green message text\n   * messageColor: \"rgb(200,200,200)\" // Light gray message text\n   * messageColor: null             // No coloring\n   * ```\n   *\n   * @default `\"rgb(148,163,184)\"` (light slate gray)\n   */\n  readonly messageColor?: Color;\n\n  /**\n   * Visual style applied to log message text.\n   *\n   * Controls the appearance of the log message content.\n   * Supports single styles, multiple styles combined, or no styling.\n   * Applied in addition to `messageColor`.\n   *\n   * @example\n   * ```typescript\n   * messageStyle: \"dim\"                      // Single style: dimmed message text\n   * messageStyle: \"italic\"                   // Single style: italic message text\n   * messageStyle: [\"dim\", \"italic\"]          // Multiple styles: dimmed + italic\n   * messageStyle: [\"bold\", \"underline\"]      // Multiple styles: bold + underlined\n   * messageStyle: null                       // No additional styling\n   * ```\n   *\n   * @default `\"dim\"` (dimmed for subtle readability)\n   */\n  readonly messageStyle?: Style;\n\n  /**\n   * Global color control for the entire formatter.\n   *\n   * Master switch to enable/disable all color output.\n   * When disabled, produces clean monochrome output suitable for\n   * non-color terminals or when colors are not desired.\n   *\n   * @example\n   * ```typescript\n   * colors: true     // Full color output (default)\n   * colors: false    // Monochrome output only\n   * ```\n   *\n   * @default `true` (colors enabled)\n   */\n  readonly colors?: boolean;\n\n  /**\n   * Column alignment for consistent visual layout.\n   *\n   * When enabled, ensures all log components (icons, levels, categories)\n   * align consistently across multiple log entries, creating a clean\n   * tabular appearance.\n   *\n   * @example\n   * ```typescript\n   * align: true      // Aligned columns (default)\n   * align: false     // Compact, non-aligned output\n   * ```\n   *\n   * @default `true` (alignment enabled)\n   */\n  readonly align?: boolean;\n\n  /**\n   * Configuration for structured value inspection and rendering.\n   *\n   * Controls how objects, arrays, and other complex values are displayed\n   * within log messages. Uses Node.js `util.inspect()` style options.\n   *\n   * @example\n   * ```typescript\n   * inspectOptions: {\n   *   depth: 3,         // Show 3 levels of nesting\n   *   colors: false,    // Disable value syntax highlighting\n   *   compact: true,    // Use compact object display\n   * }\n   * ```\n   *\n   * @default `{}` (use built-in defaults: depth=unlimited, colors=auto, compact=true)\n   */\n  readonly inspectOptions?: {\n    /**\n     * Maximum depth to traverse when inspecting nested objects.\n     * @default Infinity (no depth limit)\n     */\n    readonly depth?: number;\n\n    /**\n     * Whether to use syntax highlighting colors for inspected values.\n     * @default Inherited from global `colors` setting\n     */\n    readonly colors?: boolean;\n\n    /**\n     * Whether to use compact formatting for objects and arrays.\n     * @default `true` (compact formatting)\n     */\n    readonly compact?: boolean;\n  };\n\n  /**\n   * Configuration to always render structured data.\n   *\n   * If set to `true`, any structured data that is logged will\n   * always be rendered. This can be very verbose. Make sure\n   * to configure `inspectOptions` properly for your usecase.\n   *\n   * @default `false`\n   * @since 1.1.0\n   */\n  readonly properties?: boolean;\n\n  /**\n   * Enable word wrapping for long messages.\n   *\n   * When enabled, long messages will be wrapped at the specified width,\n   * with continuation lines aligned to the message column position.\n   *\n   * - `true`: Auto-detect terminal width when attached to a terminal,\n   *   fallback to 80 columns when not in a terminal or detection fails\n   * - `number`: Use the specified width in columns\n   * - `false`: Disable word wrapping\n   *\n   * @example\n   * ```typescript\n   * // Auto-detect terminal width (recommended)\n   * wordWrap: true\n   *\n   * // Custom wrap width\n   * wordWrap: 120\n   *\n   * // Disable word wrapping (default)\n   * wordWrap: false\n   * ```\n   *\n   * @default `true` (auto-detect terminal width)\n   * @since 1.0.0\n   */\n  readonly wordWrap?: boolean | number;\n}\n\n/**\n * Creates a beautiful console formatter optimized for local development.\n *\n * This formatter provides a Signale-inspired visual design with colorful icons,\n * smart category truncation, dimmed styling, and perfect column alignment.\n * It's specifically designed for development environments that support true colors\n * and Unicode characters.\n *\n * The formatter features:\n * - Emoji icons for each log level (üîç trace, üêõ debug, ‚ú® info, etc.)\n * - True color support with rich color schemes\n * - Intelligent category truncation for long hierarchical categories\n * - Optional timestamp display with multiple formats\n * - Configurable alignment and styling options\n * - Enhanced value rendering with syntax highlighting\n *\n * @param options Configuration options for customizing the formatter behavior.\n * @returns A text formatter function that can be used with LogTape sinks.\n *\n * @example\n * ```typescript\n * import { configure } from \"@logtape/logtape\";\n * import { getConsoleSink } from \"@logtape/logtape/sink\";\n * import { getPrettyFormatter } from \"@logtape/pretty\";\n *\n * await configure({\n *   sinks: {\n *     console: getConsoleSink({\n *       formatter: getPrettyFormatter({\n *         timestamp: \"time\",\n *         categoryWidth: 25,\n *         icons: {\n *           info: \"üìò\",\n *           error: \"üî•\"\n *         }\n *       })\n *     })\n *   }\n * });\n * ```\n *\n * @since 1.0.0\n */\nexport function getPrettyFormatter(\n  options: PrettyFormatterOptions = {},\n): TextFormatter {\n  // Extract options with defaults\n  const {\n    timestamp = \"none\",\n    timestampColor = \"rgb(100,116,139)\",\n    timestampStyle = \"dim\",\n    level: levelFormat = \"full\",\n    levelColors = {},\n    levelStyle = \"underline\",\n    icons = true,\n    categorySeparator = \"¬∑\",\n    categoryColor = \"rgb(100,116,139)\",\n    categoryColorMap = new Map(),\n    categoryStyle = [\"dim\", \"italic\"],\n    categoryWidth = 20,\n    categoryTruncate = \"middle\",\n    messageColor = \"rgb(148,163,184)\",\n    messageStyle = \"dim\",\n    colors: useColors = true,\n    align = true,\n    inspectOptions = {},\n    properties = false,\n    wordWrap = true,\n  } = options;\n\n  // Resolve icons\n  const baseIconMap: Record<LogLevel, string> = icons === false\n    ? { trace: \"\", debug: \"\", info: \"\", warning: \"\", error: \"\", fatal: \"\" }\n    : icons === true\n    ? defaultIcons\n    : { ...defaultIcons, ...(icons as Partial<Record<LogLevel, string>>) };\n\n  // Normalize icon spacing for consistent alignment\n  const iconMap = normalizeIconSpacing(baseIconMap);\n\n  // Resolve level colors with defaults\n  const resolvedLevelColors: Record<LogLevel, Color> = {\n    trace: defaultColors.trace,\n    debug: defaultColors.debug,\n    info: defaultColors.info,\n    warning: defaultColors.warning,\n    error: defaultColors.error,\n    fatal: defaultColors.fatal,\n    ...levelColors,\n  };\n\n  // Level formatter function with optimized mappings\n  const levelMappings: Record<string, Record<LogLevel, string>> = {\n    \"ABBR\": {\n      trace: \"TRC\",\n      debug: \"DBG\",\n      info: \"INF\",\n      warning: \"WRN\",\n      error: \"ERR\",\n      fatal: \"FTL\",\n    },\n    \"L\": {\n      trace: \"T\",\n      debug: \"D\",\n      info: \"I\",\n      warning: \"W\",\n      error: \"E\",\n      fatal: \"F\",\n    },\n    \"abbr\": {\n      trace: \"trc\",\n      debug: \"dbg\",\n      info: \"inf\",\n      warning: \"wrn\",\n      error: \"err\",\n      fatal: \"ftl\",\n    },\n    \"l\": {\n      trace: \"t\",\n      debug: \"d\",\n      info: \"i\",\n      warning: \"w\",\n      error: \"e\",\n      fatal: \"f\",\n    },\n  };\n\n  const formatLevel = (level: LogLevel): string => {\n    if (typeof levelFormat === \"function\") {\n      return levelFormat(level);\n    }\n\n    if (levelFormat === \"FULL\") return level.toUpperCase();\n    if (levelFormat === \"full\") return level;\n\n    return levelMappings[levelFormat]?.[level] ?? level;\n  };\n\n  // Timestamp formatters lookup table\n  const timestampFormatters: Record<string, (ts: number) => string> = {\n    \"date-time-timezone\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(\"T\", \" \").replace(\"Z\", \" +00:00\");\n    },\n    \"date-time-tz\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(\"T\", \" \").replace(\"Z\", \" +00\");\n    },\n    \"date-time\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(\"T\", \" \").replace(\"Z\", \"\");\n    },\n    \"time-timezone\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(/.*T/, \"\").replace(\"Z\", \" +00:00\");\n    },\n    \"time-tz\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(/.*T/, \"\").replace(\"Z\", \" +00\");\n    },\n    \"time\": (ts) => {\n      const iso = new Date(ts).toISOString();\n      return iso.replace(/.*T/, \"\").replace(\"Z\", \"\");\n    },\n    \"date\": (ts) => new Date(ts).toISOString().replace(/T.*/, \"\"),\n    \"rfc3339\": (ts) => new Date(ts).toISOString(),\n  };\n\n  // Resolve timestamp formatter\n  let timestampFn: ((ts: number) => string | null) | null = null;\n  if (timestamp === \"none\" || timestamp === \"disabled\") {\n    timestampFn = null;\n  } else if (typeof timestamp === \"function\") {\n    timestampFn = timestamp;\n  } else {\n    timestampFn = timestampFormatters[timestamp as string] ?? null;\n  }\n\n  // Configure word wrap settings\n  const wordWrapEnabled = wordWrap !== false;\n  let wordWrapWidth: number;\n\n  if (typeof wordWrap === \"number\") {\n    wordWrapWidth = wordWrap;\n  } else if (wordWrap === true) {\n    // Auto-detect terminal width\n    wordWrapWidth = getOptimalWordWrapWidth(80);\n  } else {\n    wordWrapWidth = 80; // Default fallback\n  }\n\n  // Prepare category color patterns for matching\n  const categoryPatterns = prepareCategoryPatterns(categoryColorMap);\n\n  // Calculate level width based on format\n  const allLevels: LogLevel[] = [...getLogLevels()];\n  const levelWidth = Math.max(...allLevels.map((l) => formatLevel(l).length));\n\n  return (record: LogRecord): string => {\n    // Calculate the prefix parts first to determine message column position\n    const icon = iconMap[record.level] || \"\";\n    const level = formatLevel(record.level);\n    const categoryStr = truncateCategory(\n      record.category,\n      categoryWidth,\n      categorySeparator,\n      categoryTruncate,\n    );\n\n    // Format message with values - handle color reset/reapply for interpolated values\n    let message = \"\";\n    const messageColorCode = useColors ? colorToAnsi(messageColor) : \"\";\n    const messageStyleCode = useColors ? styleToAnsi(messageStyle) : \"\";\n    const messagePrefix = useColors\n      ? `${messageStyleCode}${messageColorCode}`\n      : \"\";\n\n    for (let i = 0; i < record.message.length; i++) {\n      if (i % 2 === 0) {\n        message += record.message[i];\n      } else {\n        const value = record.message[i];\n        const inspected = inspect(value, {\n          colors: useColors,\n          ...inspectOptions,\n        });\n\n        // Handle multiline interpolated values properly\n        if (inspected.includes(\"\\n\")) {\n          const lines = inspected.split(\"\\n\");\n\n          const formattedLines = lines.map((line, index) => {\n            if (index === 0) {\n              // First line: reset formatting, add the line, then reapply\n              if (useColors && (messageColorCode || messageStyleCode)) {\n                return `${RESET}${line}${messagePrefix}`;\n              } else {\n                return line;\n              }\n            } else {\n              // Continuation lines: just apply formatting, let wrapText handle indentation\n              if (useColors && (messageColorCode || messageStyleCode)) {\n                return `${line}${messagePrefix}`;\n              } else {\n                return line;\n              }\n            }\n          });\n          message += formattedLines.join(\"\\n\");\n        } else {\n          // Single line - handle normally\n          if (useColors && (messageColorCode || messageStyleCode)) {\n            message += `${RESET}${inspected}${messagePrefix}`;\n          } else {\n            message += inspected;\n          }\n        }\n      }\n    }\n\n    // Parts are already calculated above\n\n    // Determine category color (with prefix matching)\n    const finalCategoryColor = useColors\n      ? (matchCategoryColor(record.category, categoryPatterns) || categoryColor)\n      : null;\n\n    // Apply colors and styling\n    const formattedIcon = icon;\n    let formattedLevel = level;\n    let formattedCategory = categoryStr;\n    let formattedMessage = message;\n    let formattedTimestamp = \"\";\n\n    if (useColors) {\n      // Apply level color and style\n      const levelColorCode = colorToAnsi(resolvedLevelColors[record.level]);\n      const levelStyleCode = styleToAnsi(levelStyle);\n      formattedLevel = `${levelStyleCode}${levelColorCode}${level}${RESET}`;\n\n      // Apply category color and style (with prefix matching)\n      const categoryColorCode = colorToAnsi(finalCategoryColor);\n      const categoryStyleCode = styleToAnsi(categoryStyle);\n      formattedCategory =\n        `${categoryStyleCode}${categoryColorCode}${categoryStr}${RESET}`;\n\n      // Apply message color and style (already handled in message building above)\n      formattedMessage = `${messagePrefix}${message}${RESET}`;\n    }\n\n    // Format timestamp if needed\n    if (timestampFn) {\n      const ts = timestampFn(record.timestamp);\n      if (ts !== null) {\n        if (useColors) {\n          const timestampColorCode = colorToAnsi(timestampColor);\n          const timestampStyleCode = styleToAnsi(timestampStyle);\n          formattedTimestamp =\n            `${timestampStyleCode}${timestampColorCode}${ts}${RESET}  `;\n        } else {\n          formattedTimestamp = `${ts}  `;\n        }\n      }\n    }\n\n    // Build the final output with alignment\n    if (align) {\n      // Calculate padding accounting for ANSI escape sequences\n      const levelColorLength = useColors\n        ? (colorToAnsi(resolvedLevelColors[record.level]).length +\n          styleToAnsi(levelStyle).length + RESET.length)\n        : 0;\n      const categoryColorLength = useColors\n        ? (colorToAnsi(finalCategoryColor).length +\n          styleToAnsi(categoryStyle).length + RESET.length)\n        : 0;\n\n      const paddedLevel = formattedLevel.padEnd(levelWidth + levelColorLength);\n      const paddedCategory = formattedCategory.padEnd(\n        categoryWidth + categoryColorLength,\n      );\n\n      let result =\n        `${formattedTimestamp}${formattedIcon} ${paddedLevel} ${paddedCategory} ${formattedMessage}`;\n      const indentWidth = getDisplayWidth(\n        stripAnsi(\n          `${formattedTimestamp}${formattedIcon} ${paddedLevel} ${paddedCategory} `,\n        ),\n      );\n\n      // Apply word wrapping if enabled, or if there are multiline interpolated values\n      if (wordWrapEnabled || message.includes(\"\\n\")) {\n        result = wrapText(\n          result,\n          wordWrapEnabled ? wordWrapWidth : Infinity,\n          indentWidth,\n        );\n      }\n\n      if (properties) {\n        result += formatProperties(\n          record,\n          indentWidth,\n          wordWrapEnabled ? wordWrapWidth : Infinity,\n          useColors,\n          inspectOptions,\n        );\n      }\n\n      return result + \"\\n\";\n    } else {\n      let result =\n        `${formattedTimestamp}${formattedIcon} ${formattedLevel} ${formattedCategory} ${formattedMessage}`;\n      const indentWidth = getDisplayWidth(\n        stripAnsi(\n          `${formattedTimestamp}${formattedIcon} ${formattedLevel} ${formattedCategory} `,\n        ),\n      );\n\n      // Apply word wrapping if enabled, or if there are multiline interpolated values\n      if (wordWrapEnabled || message.includes(\"\\n\")) {\n        result = wrapText(\n          result,\n          wordWrapEnabled ? wordWrapWidth : Infinity,\n          indentWidth,\n        );\n      }\n\n      if (properties) {\n        result += formatProperties(\n          record,\n          indentWidth,\n          wordWrapEnabled ? wordWrapWidth : Infinity,\n          useColors,\n          inspectOptions,\n        );\n      }\n\n      return result + \"\\n\";\n    }\n  };\n}\n\nfunction formatProperties(\n  record: LogRecord,\n  indentWidth: number,\n  maxWidth: number,\n  useColors: boolean,\n  inspectOptions: InspectOptions,\n): string {\n  let result = \"\";\n  for (const prop in record.properties) {\n    const propValue = record.properties[prop];\n    // Ensure padding is never negative\n    const pad = Math.max(0, indentWidth - getDisplayWidth(prop) - 2);\n    result += \"\\n\" + wrapText(\n      `${\" \".repeat(pad)}${useColors ? DIM : \"\"}${prop}:${\n        useColors ? RESET : \"\"\n      } ${inspect(propValue, { colors: useColors, ...inspectOptions })}`,\n      maxWidth,\n      indentWidth,\n    );\n  }\n  return result;\n}\n\n/**\n * A pre-configured beautiful console formatter for local development.\n *\n * This is a ready-to-use instance of the pretty formatter with sensible defaults\n * for most development scenarios. It provides immediate visual enhancement to\n * your logs without requiring any configuration.\n *\n * Features enabled by default:\n * - Emoji icons for all log levels\n * - True color support with rich color schemes\n * - Dimmed text styling for better readability\n * - Smart category truncation (20 characters max)\n * - Perfect column alignment\n * - No timestamp display (cleaner for development)\n *\n * For custom configuration, use {@link getPrettyFormatter} instead.\n *\n * @example\n * ```typescript\n * import { configure } from \"@logtape/logtape\";\n * import { getConsoleSink } from \"@logtape/logtape/sink\";\n * import { prettyFormatter } from \"@logtape/pretty\";\n *\n * await configure({\n *   sinks: {\n *     console: getConsoleSink({\n *       formatter: prettyFormatter\n *     })\n *   }\n * });\n * ```\n *\n * @since 1.0.0\n */\nexport const prettyFormatter: TextFormatter = getPrettyFormatter();\n"],"mappings":"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"}